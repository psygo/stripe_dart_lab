# [Stripe API][stripe_api]


[stripe_api]: https://stripe.com/docs/api?lang=curl

---

**Table of Contents**

<style>
  #TOC ul {
    list-style-type: none;
  }
</style>

<div id="TOC">
  <ul>
    <li><a href="#1-authentication">1. Authentication</a></li>
    <li><a href="#2-errors">2. Errors</a></li>
    <li><a href="#3-idempotent-requests">3. Idempotent Requests</a></li>
    <li><a href="#4-metadata">4. Metadata</a></li>
  </ul>
</div>

---

## 1. Authentication

You can also set a per-request key with an option. This is often useful for Connect applications that use multiple API keys during the lifetime of a process. Methods on the returned object reuse the same API key.

All API requests must be made over HTTPS. Calls made over plain HTTP will fail. API requests without authentication will also fail.

## 2. Errors

In the error page, you will find all of the respective attributes of an error message.

## 3. Idempotent Requests

The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response. For example, if a request to create a charge does not respond due to a network connection error, you can retry the request with the same idempotency key to guarantee that no more than one charge is created.

An idempotency key is a unique value generated by the client which the server uses to recognize subsequent retries of the same request. How you create unique keys is up to you, but we suggest using V4 UUIDs, or another random string with enough entropy to avoid collisions.

## 4. Metadata

Updateable Stripe objects—including Account, Charge, Customer, PaymentIntent, Refund, Subscription, and Transfer—have a metadata parameter. You can use this parameter to attach key-value data to these Stripe objects.

You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.

> Updating these data both in Firebase and Stripe might be a good idea, but it would also be easy to forget. But we could use OOP to ensure that both updates occur via an interface for both updates.